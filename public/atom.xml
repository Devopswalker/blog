<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>四多&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://vmee.top/"/>
  <updated>2018-07-14T17:37:56.000Z</updated>
  <id>http://vmee.top/</id>
  
  <author>
    <name>四多</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>区块链基础理论之行业词典</title>
    <link href="http://vmee.top/2018/07/15/industry-dictionary-of-blockchain/"/>
    <id>http://vmee.top/2018/07/15/industry-dictionary-of-blockchain/</id>
    <published>2018-07-14T17:37:56.000Z</published>
    <updated>2018-07-14T17:37:56.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由 <strong>维京研究院 &amp; 甲子智库</strong> 合力推出的 《<strong>区块链行业词典</strong>》 整理记录；</p></blockquote><h2 id="民间暗语（小白入门首选）"><a href="#民间暗语（小白入门首选）" class="headerlink" title="民间暗语（小白入门首选）"></a>民间暗语（小白入门首选）</h2><h3 id="韭菜"><a href="#韭菜" class="headerlink" title="韭菜"></a>韭菜</h3><blockquote><p>指不了解市场情况的散户。因为散户不了解市场情况且容易受到投资情绪左右，容易高位买入、低价卖出，而当一部分人亏损离场后又会有新生力量进入，就像韭菜一样割一茬很快又长一茬。</p></blockquote><h3 id="割韭菜"><a href="#割韭菜" class="headerlink" title="割韭菜"></a>割韭菜</h3><blockquote><p>指庄家低位买入，炒高币价等散户进来后高价卖出获利，再砸盘砸到低位重复以上套 路。而散户就像韭菜一样，割完又有新的一批入场。【最近李笑来录音曝光的庄家收割韭菜套路可以了解一下】</p></blockquote><h3 id="糖果-Candy"><a href="#糖果-Candy" class="headerlink" title="糖果/ Candy"></a>糖果/ Candy</h3><blockquote><p>加密货币在项目起步时都需要推广，常见的推广方式之一就是“发糖果”，即免费向用 户发放一定数量虚拟币，这些免费的虚拟币被用户们称之为“糖果”。[因为虚拟货币的市场波动性很强，薅羊毛之风盛行]</p></blockquote><h3 id="炒币"><a href="#炒币" class="headerlink" title="炒币"></a>炒币</h3><blockquote><p>为获取高额利润，在各交易所反复买卖加密货币的行为。</p></blockquote><h3 id="腰斩"><a href="#腰斩" class="headerlink" title="腰斩"></a>腰斩</h3><blockquote><p>指加密货币的价格下跌后相对于先前最高价位只有一半的水平。</p></blockquote><h3 id="割肉"><a href="#割肉" class="headerlink" title="割肉"></a>割肉</h3><blockquote><p>指在加密货币价格下跌时减持的止损行为。提前设立好止损价位，防止更大的损失，是短线投资者应灵活运用的方法，新股民使用可防止深度套牢。</p></blockquote><h3 id="爱西欧"><a href="#爱西欧" class="headerlink" title="爱西欧"></a>爱西欧</h3><blockquote><p>ICO 的拟声词 ++[监管原因]++，指首次发行代币，是用区块链把使用权和加密货币合二为一，来为开发、维护、交换相关产品或者服务的项目进行融资的方式。</p></blockquote><h3 id="思慕"><a href="#思慕" class="headerlink" title="思慕"></a>思慕</h3><blockquote><p>私募 的拟声词 ++[监管原因]++，基金行业高频词，一般指不对外公开销售的项目的一种内部渠道融资方式。</p></blockquote><h3 id="白皮书"><a href="#白皮书" class="headerlink" title="白皮书"></a>白皮书</h3><blockquote><p>就是一个区块链项目团队对外公布的可代表官方立场的文件，内容一般是项目详细介绍与官方说明，例如这是一个基于区块链技术的电商方案，初衷与愿景是什么，可以解决怎么样的问题，技术是怎么用的，商业模式如何，是否会发行Token，如果发行各参与者的权益如何分配，项目未来的规划如何等等。</p></blockquote><h3 id="PPT-融资"><a href="#PPT-融资" class="headerlink" title="PPT 融资"></a>PPT 融资</h3><blockquote><p>当一个项目进行首次币发行时，需要发布 ICO 白皮书来披露项目情况、发行的代币数 量、筹集资金的用途等信息。白皮书通常以 PDF、PPT 等文件格式发布在项目官网或 相关专业网站上，“白皮书”在 ICO 中的作用就和招股说明书在 IPO 中的作用类似， 但由于 ICO 项目极大程度地依赖于白皮书是否制作精良，因此被称之为“PPT 融资”。</p></blockquote><h3 id="空气币"><a href="#空气币" class="headerlink" title="空气币"></a>空气币</h3><blockquote><p>空气币指没有任何技术依托的 ICO 代币，通过传销机构吹捧而号称有广大远景，但实 际上不可行或是无法兑现。与国外相比，国内的 ICO 项目伴随着诸多“空气币”骗局。</p></blockquote><h3 id="传销币"><a href="#传销币" class="headerlink" title="传销币"></a>传销币</h3><blockquote><p>传销币采用拉人头的方式获利。和开启项目后投资者获币不同，传销币成本不清，而且可能长期超发以满足新的受害者持币的心理。传销币完全抄袭别人的开源代码来搭建程序，且项目方长期不更新代码也不公布项目进度。</p></blockquote><h3 id="币圈-Coin-Community"><a href="#币圈-Coin-Community" class="headerlink" title="币圈/ Coin Community"></a>币圈/ Coin Community</h3><blockquote><p>“币圈”指的是专注于炒币，甚至发行自己的加密货币进行筹资(即代币众筹)的人群，<br>业内俗称“币圈”。</p></blockquote><h3 id="矿圈-Mine-Community"><a href="#矿圈-Mine-Community" class="headerlink" title="矿圈/ Mine Community"></a>矿圈/ Mine Community</h3><blockquote><p>“矿圈”指的是专注于“挖矿”的“矿工”人群。</p></blockquote><h3 id="矿难-Mine-Disaster"><a href="#矿难-Mine-Disaster" class="headerlink" title="矿难/ Mine Disaster"></a>矿难/ Mine Disaster</h3><blockquote><p>虚拟货币矿难指的是当挖掘成本(主要是矿机和电费)高于市场价时，继续挖矿也无法 赚取虚拟货币收益。“矿难”时，大量挖矿玩家停止挖矿，而前期购买的显卡等硬件可 能会以较低的价格出售，因此虚拟货币的矿难会极大地缓解显卡缺货的局面。</p></blockquote><h3 id="链圈-Chain-Community"><a href="#链圈-Chain-Community" class="headerlink" title="链圈/ Chain Community"></a>链圈/ Chain Community</h3><blockquote><p>“链圈”指的是专注于区块链的研发、应用或区块链底层协议的人群。【圈内鄙视链：币圈 &lt; 矿圈 &lt; 链圈 &lt; <strong>韭菜</strong>】</p></blockquote><h3 id="佛系买币-持币"><a href="#佛系买币-持币" class="headerlink" title="佛系买币/持币"></a>佛系买币/持币</h3><blockquote><p>指持币后不关心加密货币价格走势，无论加密货币资产价格跌到什么程度，都不会减持手中的加密货币的行为（也有称==价值投资==）。</p></blockquote><hr><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="区块链定义"><a href="#区块链定义" class="headerlink" title="区块链定义"></a>区块链定义</h3><h4 id="区块链-Blockchain"><a href="#区块链-Blockchain" class="headerlink" title="区块链/ Blockchain"></a>区块链/ Blockchain</h4><blockquote><p>区块链技术是指通过去中心化和去信任的方式集体维护一个可靠数据库的技术方案。</p></blockquote><h4 id="块链式数据结构-Chained-Block-Data-Structure"><a href="#块链式数据结构-Chained-Block-Data-Structure" class="headerlink" title="块链式数据结构/ Chained-Block Data Structure"></a>块链式数据结构/ Chained-Block Data Structure</h4><blockquote><p>一段时间内发生的事务处理以区块为单位进行存储，并以密码学算法将区块按时间先后 顺序连接成链条的一种数据结构。</p></blockquote><h4 id="去信任-Trustless"><a href="#去信任-Trustless" class="headerlink" title="去信任/ Trustless"></a>去信任/ Trustless</h4><blockquote><p>去信任表示用户不需要相信任何第三方。用户使用去信任的系统或技术处理交易时非常 安全和顺畅，交易双方都可以安全地交易，而不需要依赖信任的第三方。</p></blockquote><h4 id="点对点-Peer-to-Peer-P2P"><a href="#点对点-Peer-to-Peer-P2P" class="headerlink" title="点对点/ Peer-to-Peer / P2P"></a>点对点/ Peer-to-Peer / P2P</h4><blockquote><p>通过允许单个节点与其他节点直接交互，无需通过中介机构，从而实现整个系统像有组 织的集体一样运作的系统。</p></blockquote><h4 id="去中心化-Decentralized"><a href="#去中心化-Decentralized" class="headerlink" title="去中心化/ Decentralized"></a>去中心化/ Decentralized</h4><blockquote><p>去中心化是区块链最基本的特征，指区块链不依赖于中心的管理节点，能够实现数据的 分布式记录、存储和更新。</p></blockquote><h4 id="中本聪-Satoshis-Nakamoto"><a href="#中本聪-Satoshis-Nakamoto" class="headerlink" title="中本聪/ Satoshis Nakamoto"></a>中本聪/ Satoshis Nakamoto</h4><blockquote><p>中本聪是比特币的发明人或发明组织，目前身份存疑。“中本聪”也可能仅仅是个化名。 中本聪于 2008 年发表了一篇名为《比特币:一种点对点式的电子现金系统》(Bitcoin: A Peer-to-Peer Electronic Cash System)的论文，描述了一种被称为“比特币”的电子 货币及其算法，被视为是区块链的第一个成功实践。</p></blockquote><h3 id="区块链特性"><a href="#区块链特性" class="headerlink" title="区块链特性"></a>区块链特性</h3><h4 id="匿名性-Anonymous"><a href="#匿名性-Anonymous" class="headerlink" title="匿名性/ Anonymous"></a>匿名性/ Anonymous</h4><blockquote><p>由于区块链各节点之间的数据交换遵循固定且预知的算法，因此区块链网络是无须信任 的，可以基于地址而非个人身份进行数据交换。</p></blockquote><h4 id="自治性-Autonomous"><a href="#自治性-Autonomous" class="headerlink" title="自治性/ Autonomous"></a>自治性/ Autonomous</h4><blockquote><p>区块链采用基于协商一致的机制，使整个系统中的所有节点能在去信任的环境自由安全 地交换数据、记录数据、更新数据，任何人为的干预都不起作用。</p></blockquote><h4 id="开放性-Openness"><a href="#开放性-Openness" class="headerlink" title="开放性/ Openness"></a>开放性/ Openness</h4><blockquote><p>区块链系统是开放的，任何节点都能够拥有全网的总账本，除了数据直接相关各方的私 有信息通过非对称加密技术被加密外，区块链的数据对所有节点公开，因此整个系统信 息高度透明。</p></blockquote><h4 id="可编程-Programmable"><a href="#可编程-Programmable" class="headerlink" title="可编程/ Programmable"></a>可编程/ Programmable</h4><blockquote><p>分布式账本的数字性质意味着区块链交易可以关联到计算逻辑，并且本质上是可编程 的。因此，用户可以设置自动触发节点之间交易的算法和规则。</p></blockquote><h4 id="可追溯-Traceability"><a href="#可追溯-Traceability" class="headerlink" title="可追溯/ Traceability"></a>可追溯/ Traceability</h4><blockquote><p>区块链通过区块数据结构存储了创世区块后的所有历史数据，区块链上的任一一条数据 皆可通过链式结构追溯其本源。</p></blockquote><h4 id="不可篡改-Tamper-Proof"><a href="#不可篡改-Tamper-Proof" class="headerlink" title="不可篡改/ Tamper Proof"></a>不可篡改/ Tamper Proof</h4><blockquote><p>区块链的信息通过共识并添加至区块链后，就被所有节点共同记录，并通过密码学保证 前后互相关联，篡改的难度与成本非常高。</p></blockquote><h4 id="集体维护-Collectively-Maintain"><a href="#集体维护-Collectively-Maintain" class="headerlink" title="集体维护/ Collectively Maintain"></a>集体维护/ Collectively Maintain</h4><blockquote><p>区块链系统是由其中所有具有维护功能的节点共同维护，所有节点都可以通过公开的接 口查询区块链数据和开发相关应用。</p></blockquote><h4 id="无需许可-Permissionless"><a href="#无需许可-Permissionless" class="headerlink" title="无需许可/ Permissionless"></a>无需许可/ Permissionless</h4><blockquote><p>无需许可表示所有节点都可以请求将任何交易添加到区块链中，但只有在所有用户都认 为合法的情况下才可进行交易。</p></blockquote><h3 id="区块链类型"><a href="#区块链类型" class="headerlink" title="区块链类型"></a>区块链类型</h3><p>==根据应用范围==</p><h4 id="公有链-Public-Blockchain"><a href="#公有链-Public-Blockchain" class="headerlink" title="公有链/ Public Blockchain"></a>公有链/ Public Blockchain</h4><blockquote><p>公有链的任何节点都是向任何人开放的，每个人都可以参与到这个区块链中的计算，而且任何人都可以下载获得完整区块链数据，即全部账本。</p></blockquote><h4 id="联盟链-Consortium-Blockchain"><a href="#联盟链-Consortium-Blockchain" class="headerlink" title="联盟链/ Consortium Blockchain"></a>联盟链/ Consortium Blockchain</h4><blockquote><p>联盟链是指参与每个节点的权限都完全对等，各节点在不需要完全互信的情况下就可以实现数据的可信交换，联盟链的各个节点通常有与之对应的实体机构组织，通过授权后才能加入或退出网络。联盟链是一种公司与公司、组织与组织之间达成联盟的模式。</p></blockquote><h4 id="私有链-Private-Blockchain"><a href="#私有链-Private-Blockchain" class="headerlink" title="私有链/ Private Blockchain"></a>私有链/ Private Blockchain</h4><blockquote><p>在某些区块链的应用场景下，开发者并不希望任何人都可以参与这个系统，因此建立一种不对外公开、只有被许可的节点才可以参与并且查看所有数据的私有区块链，私有链一般适用于特定机构的内部数据管理与审计。</p></blockquote><p>==根据部署机制==</p><h4 id="主链-主网-Main-net"><a href="#主链-主网-Main-net" class="headerlink" title="主链/ 主网/ Main net"></a>主链/ 主网/ Main net</h4><blockquote><p>通常区块链，尤其是公有链都有主网和测试网。主网是区块链社区公认的可信区块链网络，其交易信息被全体成员所认可。有效的区块在经过区块链网络的共识后会被追加到主网的区块账本中。</p></blockquote><h4 id="测试链-测试网-Testnet"><a href="#测试链-测试网-Testnet" class="headerlink" title="测试链/ 测试网/ Testnet"></a>测试链/ 测试网/ Testnet</h4><blockquote><p>测试链是对应主网具有相同功能，但主要目的用于测试的区块链。由于测试链是为了在不破坏主链的情况下尝试新想法而建立的，只作为测试用途，因此测试链上的测试币不具备交易价值。比特币的测试链已经历多次重置，以阻止将其测试币用作交易、投机用途的行为。</p></blockquote><p>==根据对接类型==</p><h4 id="侧链-Side-Chain"><a href="#侧链-Side-Chain" class="headerlink" title="侧链/ Side Chain"></a>侧链/ Side Chain</h4><blockquote><p>侧链是主链外的另一个区块链，锚定主链中的某一个节点，通过主链上的计算力来维护侧链的真实性，实现公共区块链上价值与其他账簿上价值在多个区块链间的转移。最具代表性的实现有 Blockstream。这种主链和侧链协同的区块链架构中的主链有时也被称为母链(Parent chain)。</p></blockquote><h4 id="互联链-InterChains"><a href="#互联链-InterChains" class="headerlink" title="互联链/ InterChains"></a>互联链/ InterChains</h4><blockquote><p>针对特定领域的应用可能会形成各自垂直领域的区块链，互联链就是一种通过跨链技术连接不同区块链的基础设施:包括数据结构和通信协议，其本身通常也是区块链。各种不同的区块链通过互联链互联互通并形成更大的区块链生态。与互联网一样，互联链的建立将形成区块链的全球网络。</p></blockquote><h3 id="区块链层级结构"><a href="#区块链层级结构" class="headerlink" title="区块链层级结构"></a>区块链层级结构</h3><h4 id="数据层-Data-Layer"><a href="#数据层-Data-Layer" class="headerlink" title="数据层/ Data Layer"></a>数据层/ Data Layer</h4><blockquote><p>数据层主要描述区块链的物理形式，是区块链上从创世区块起始的链式结构，包含了区 块链的区块数据、链式结构以及区块上的随机数、时间戳、公私钥数据等，是整个区块 链技术中最底层的数据结构。</p></blockquote><h4 id="网络层-Network-Layer"><a href="#网络层-Network-Layer" class="headerlink" title="网络层/ Network Layer"></a>网络层/ Network Layer</h4><blockquote><p>网络层主要通过 P2P 技术实现分布式网络的机制，网络层包括 P2P 组网机制、数据传 播机制和数据验证机制，因此区块链本质上是一个 P2P 的网络，具备自动组网的机制， 节点之间通过维护一个共同的区块链结构来保持通信。</p></blockquote><h4 id="共识层-Consensus-Layer"><a href="#共识层-Consensus-Layer" class="headerlink" title="共识层/ Consensus Layer"></a>共识层/ Consensus Layer</h4><blockquote><p>共识层主要包含共识算法以及共识机制，能让高度分散的节点在去中心化的区块链网络中高效地针对区块数据的有效性达成共识，是区块链的核心技术之一，也是区块链社群的治理机制。目前至少有数十种共识机制算法，包含工作量证明、权益证明、权益授权证明、燃烧证明、重要性证明等。</p></blockquote><html><br>    <span style="color:#c4192d;font-weight:bold;font-size:16px;"><br>    数据层、网络层、共识层是构建区块链技术的必要元素，缺少任何一层都不能称之为真正意义上的区块链技术。<br>    </span><br></html><h4 id="激励层-Actuator-Layer"><a href="#激励层-Actuator-Layer" class="headerlink" title="激励层/ Actuator Layer"></a>激励层/ Actuator Layer</h4><blockquote><p>激励层主要包括经济激励的发行制度和分配制度，其功能是提供一定的激励措施，鼓励节点参与区块链中安全验证工作，并将经济因素纳入到区块链技术体系中，激励遵守规则参与记账的节点，并惩罚不遵守规则的节点。</p></blockquote><h4 id="合约层-Contract-Layer"><a href="#合约层-Contract-Layer" class="headerlink" title="合约层/ Contract Layer"></a>合约层/ Contract Layer</h4><blockquote><p>合约层主要包括各种脚本、代码、算法机制及智能合约，是区块链可编程的基础。将代码嵌入区块链或是令牌中，实现可以自定义的智能合约，并在达到某个确定的约束条件的情况下，无需经由第三方就能够自动执行，是区块链去信任的基础。</p></blockquote><h4 id="应用层-Application-Layer"><a href="#应用层-Application-Layer" class="headerlink" title="应用层/ Application Layer"></a>应用层/ Application Layer</h4><blockquote><p>区块链的应用层封装了各种应用场景和案例，类似于电脑操作系统上的应用程序、互联网浏览器上的门户网站、搜寻引擎、电子商城或是手机端上的 APP，将区块链技术应 用部署在如以太坊、EOS、QTUM 上并在现实生活场景中落地。未来的可编程金融和可编程社会也将会是搭建在应用层上。</p></blockquote><html><br>    <span style="color:#c4192d;font-weight:bold;font-size:16px;"><br>    激励层、合约层和应用层不是每个区块链应用的必要因素，一些区块链应用并不完整包 含此三层结构。<br>    </span><br></html><h2 id="区块链的基本技术"><a href="#区块链的基本技术" class="headerlink" title="区块链的基本技术"></a>区块链的基本技术</h2><h3 id="区块数据"><a href="#区块数据" class="headerlink" title="区块数据"></a>区块数据</h3><h4 id="区块-Block"><a href="#区块-Block" class="headerlink" title="区块/ Block"></a>区块/ Block</h4><blockquote><p>区块是在区块链网络上承载交易数据的数据包，是一种被标记上时间戳和之前一个区块的哈希值的数据结构，区块经过网络的共识机制验证并确认区块中的交易。</p></blockquote><h4 id="父块-Parent-Block"><a href="#父块-Parent-Block" class="headerlink" title="父块/ Parent Block"></a>父块/ Parent Block</h4><blockquote><p>父块是指区块的前一个区块，区块链通过在区块头记录区块以及父块的哈希值来在时间上排序。</p></blockquote><h4 id="区块头-Block-Header"><a href="#区块头-Block-Header" class="headerlink" title="区块头/ Block Header"></a>区块头/ Block Header</h4><blockquote><p>记录当前区块的元信息，包含当前版本号、上一区块的哈希值、时间戳、随机数、 Merkle Root 的哈希值等数据。此外，区块体的数据记录通过 Merkle Tree 的哈希过程生成唯一的<br>Merkle Root 记录于区块头。</p></blockquote><h4 id="区块体-Block-Body"><a href="#区块体-Block-Body" class="headerlink" title="区块体/ Block Body"></a>区块体/ Block Body</h4><blockquote><p>记录一定时间内所生成的详细数据，包括当前区块经过验证的、区块创建过程中生成的所有交易记录或是其他信息，可以理解为账本的一种表现形式。</p></blockquote><h4 id="哈希值-散列值-Hash-Values-Hash-Codes-Hash-Sums-Hashes"><a href="#哈希值-散列值-Hash-Values-Hash-Codes-Hash-Sums-Hashes" class="headerlink" title="哈希值/ 散列值/ Hash Values / Hash Codes / Hash Sums / Hashes"></a>哈希值/ 散列值/ Hash Values / Hash Codes / Hash Sums / Hashes</h4><blockquote><p>哈希值通常用一个短的随机字母和数字组成的字符串来代表，是一组任意长度的输入信息通过哈希算法得到的“数据指纹”。因为计算机在底层机器码是采用二进制的模式， 因此通过哈希算法得到的任意长度的二进制值映射为较短的固定长度的二进制值，即哈 希值。此外，哈希值是一段数据唯一且极其紧凑的数值表示形式，如果通过哈希一段明 文得到哈希值，哪怕只更改该段明文中的任意一个字母，随后得到的哈希值都将不同。</p></blockquote><h4 id="时间戳-Timestamp"><a href="#时间戳-Timestamp" class="headerlink" title="时间戳/ Timestamp"></a>时间戳/ Timestamp</h4><blockquote><p>时间戳从区块生成的那一刻起就存在于区块之中，是用于标识交易时间的字符序列，具 备唯一性，时间戳用以记录并表明存在的、完整的、可验证的数据，是每一次交易记录 的认证。</p></blockquote><h4 id="随机数-一次性的随机数-Nonce"><a href="#随机数-一次性的随机数-Nonce" class="headerlink" title="随机数/ 一次性的随机数/ Nonce"></a>随机数/ 一次性的随机数/ Nonce</h4><blockquote><p>Nonce 是指“只使用一次的随机数”，在挖矿中是一种用于挖掘加密货币的自动生成的、 毫无意义的随机数，在解决数学难题的问题中被使用一次之后，如果不能解决该难题则该随机数就会被拒绝，而一个新的 Nonce 也会被测试出来并且直到问题解决，当问题 解决时矿工就会得到加密货币作为奖励。在区块结构中，Nonce 是基于工作量证明所设 计的随机数字，通过难度调整来增加或减少其计算时间;在信息安全中，Nonce 是一个 在加密通信只能使用一次的数字;在认证协议中，Nonce 是一个随机或伪随机数，以避免重放攻击。</p></blockquote><h4 id="梅克尔树-Merkle-Tree"><a href="#梅克尔树-Merkle-Tree" class="headerlink" title="梅克尔树/ Merkle Tree"></a>梅克尔树/ Merkle Tree</h4><blockquote><p>梅克尔树(又叫哈希树)是一种二叉树，是一种高效和安全的组织数据的方法，被用来 快速查询验证特定交易是否存在，由一个根节点、一组中间节点和一组叶节点组成。它 使用哈希算法将大量的书面信息转换成一串独立的字母或数字。最底层的叶节点包含存 储数据或其哈希值，每个中间节点是它的两个子节点内容的哈希值，根节点也是由它的 两个子节点内容的哈希值组成。</p></blockquote><h4 id="区块容量-Block-Size"><a href="#区块容量-Block-Size" class="headerlink" title="区块容量/ Block Size"></a>区块容量/ Block Size</h4><blockquote><p>区块链的每个区块，都是用来承载某个时间段内的数据的，每个区块通过时间的先后顺 序，使用密码学技术将其串联起来，形成一个完整的分布式数据库，区块容量代表了一 个区块能容纳多少数据的能力。</p></blockquote><h4 id="未花费的交易输出-Unspent-Transaction-Output-UTXO"><a href="#未花费的交易输出-Unspent-Transaction-Output-UTXO" class="headerlink" title="未花费的交易输出/ Unspent Transaction Output / UTXO"></a>未花费的交易输出/ Unspent Transaction Output / UTXO</h4><blockquote><p>未花费的交易输出是一个包含交易数据和执行代码的数据结构，可以理解为收到的但尚 未花费的加密货币清单。比特币和其他加密货币在其区块链技术中使用 UTXO，以验 证一个人是否拥有未使用的加密货币可用于支出。</p></blockquote><h3 id="链式结构"><a href="#链式结构" class="headerlink" title="链式结构"></a>链式结构</h3><h4 id="链-Chain"><a href="#链-Chain" class="headerlink" title="链/ Chain"></a>链/ Chain</h4><blockquote><p>链是由区块按照发生的时间顺序，通过区块的哈希值串联而成，是区块交易记录及状态 变化的日志记录。</p></blockquote><h4 id="链下-Off-chain"><a href="#链下-Off-chain" class="headerlink" title="链下/ Off-chain"></a>链下/ Off-chain</h4><blockquote><p>区块链系统从功能角度讲，是一个价值交换网络，链下是指不存储于区块链上的数据。</p></blockquote><h4 id="无代币区块链-Token-Less-Blockchain"><a href="#无代币区块链-Token-Less-Blockchain" class="headerlink" title="无代币区块链/ Token-Less Blockchain"></a>无代币区块链/ Token-Less Blockchain</h4><blockquote><p>即区块链并不通过代币进行价值交换，一般出现在不需要在节点之间转移价值并且仅在 不同的已被信任方之间共享数据的情况下，如私有链。</p></blockquote><h4 id="创世区块-Genesis-Block"><a href="#创世区块-Genesis-Block" class="headerlink" title="创世区块/ Genesis Block"></a>创世区块/ Genesis Block</h4><blockquote><p>区块链中的第一个区块被称为“创世”区块。创世区块一般用于初始化，不带有交易信 息。</p></blockquote><h4 id="区块高度-Block-Height"><a href="#区块高度-Block-Height" class="headerlink" title="区块高度/ Block Height"></a>区块高度/ Block Height</h4><blockquote><p>一个区块的高度是指在区块链中它和创世区块之间的块数。</p></blockquote><h4 id="分叉-Fork"><a href="#分叉-Fork" class="headerlink" title="分叉/ Fork"></a>分叉/ Fork</h4><blockquote><p>在区块链中，由矿工挖出区块并将其链接到主链上，一般来讲同一时间内只产生一个区块，如果发生同一时间内有两个区块同时被生成的情况，就会在全网中出现两个长度相同、区块里的交易信息相同但矿工签名不同或者交易排序不同的区块链，这样的情况叫做分叉。</p></blockquote><h4 id="软分叉-Soft-Fork"><a href="#软分叉-Soft-Fork" class="headerlink" title="软分叉/ Soft Fork"></a>软分叉/ Soft Fork</h4><blockquote><p>指在区块链或去中心化网络中向前兼容的分叉。向前兼容意味着，当新共识规则发布 后，在去中心化架构中节点不一定要升级到新的共识规则，因为软分叉的新规则仍旧符 合老的规则，所以未升级的节点仍旧能接受新的规则。</p></blockquote><h4 id="硬分叉-Hard-Fork"><a href="#硬分叉-Hard-Fork" class="headerlink" title="硬分叉/ Hard Fork"></a>硬分叉/ Hard Fork</h4><blockquote><p>指在区块链或去中心化网络中不向前兼容的分叉，硬分叉对加密货币使用的技术进行永久更改，这种变化使得所有的新数据块与原来的块不同，旧版本不会接受新版本创建的区块，要实现硬分叉所有用户都需要切换到新版本协议上。如果新的硬分叉失败，所有的用户将回到原始数据块。</p></blockquote><h4 id="幽灵协议-GHOST-Protocol"><a href="#幽灵协议-GHOST-Protocol" class="headerlink" title="幽灵协议/ GHOST Protocol"></a>幽灵协议/ GHOST Protocol</h4><blockquote><p>通过幽灵协议，区块可以包含不只是他们父块的哈希值，也包含其父块的父块的其他子块(被称为叔块)的陈腐区块的哈希值，这确保了陈腐区块仍然有助于区块链的安全 性，并能够获得一定比例的区块奖励，减少了大型矿工在区块链上的中心化倾向问题。</p></blockquote><h4 id="孤块-Orphan-Block"><a href="#孤块-Orphan-Block" class="headerlink" title="孤块/ Orphan Block"></a>孤块/ Orphan Block</h4><blockquote><p>孤块是一个被遗弃的数据块。因为很多节点都在维护区块链并同时创建多个区块，但是一次只能有一个被继续继承，而其它被遗弃的数据块就是孤块。</p></blockquote><h4 id="陈腐区块-Stale-Block"><a href="#陈腐区块-Stale-Block" class="headerlink" title="陈腐区块/ Stale Block"></a>陈腐区块/ Stale Block</h4><blockquote><p>是父块的父块的“其他”子块，或更一般的说是祖先的其他子块，但不是自己的祖先， 如果 A 是 B 的一个叔块，那 B 是 A 的侄块。</p></blockquote><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><h4 id="密码学-Cryptography"><a href="#密码学-Cryptography" class="headerlink" title="密码学/ Cryptography"></a>密码学/ Cryptography</h4><blockquote><p>密码学是数学和计算机科学的分支，同时其原理大量涉及信息论。密码学不只关注信息保密问题，还同时涉及信息完整性验证(消息验证码)、信息发布的不可抵赖性(数字 签名)、以及在分布式计算中产生的来源于内部和外部的攻击的所有信息安全问题。</p></blockquote><h4 id="加密-Cipher"><a href="#加密-Cipher" class="headerlink" title="加密/ Cipher"></a>加密/ Cipher</h4><blockquote><p>加密是一系列使信息不可读的过程，它能使信息加密也能使信息加密后能够再次可读，在加密货币中使用的密码也使用由字母和数字组成的密钥，该密钥必须用于解密密码。</p></blockquote><h4 id="加密算法-Encryption-Algorithm"><a href="#加密算法-Encryption-Algorithm" class="headerlink" title="加密算法/ Encryption Algorithm"></a>加密算法/ Encryption Algorithm</h4><blockquote><p>加密算法是一个函数，也可以视为是一把钥匙，通过使用一个加密钥匙，将原来的明文 文件或数据转化成一串不可读的密文代码。加密流程是不可逆的，只有持有对应的解密 钥匙才能将该加密信息解密成可阅读的明文。加密使得私密数据可以在低风险的情况 下，通过公共网络进行传输，并保护数据不被第三方窃取、阅读。</p></blockquote><h4 id="非对称加密-Asymmetric-Cryptography"><a href="#非对称加密-Asymmetric-Cryptography" class="headerlink" title="非对称加密/ Asymmetric Cryptography"></a>非对称加密/ Asymmetric Cryptography</h4><blockquote><p>非对称加密是一种保证区块链安全的基础技术。该技术含有两个密钥:公钥和私钥，首 先，系统按照某种密钥生成算法，将输入经过计算得出私钥，然后，采用另一个算法根 据私钥生成公钥，公钥的生成过程不可逆。由于在现有的计算能力条件下难以通过公钥 来穷举出私钥(即计算上不可行)，因此可以认为是数据是安全的，从而能够保证区块 链的数据安全。</p></blockquote><h4 id="同态加密-Homomorphic-Encryption"><a href="#同态加密-Homomorphic-Encryption" class="headerlink" title="同态加密/ Homomorphic Encryption"></a>同态加密/ Homomorphic Encryption</h4><blockquote><p>同态加密是一种特殊的加密方法，允许对密文根据特定的代数运算方式进行处理后得到的仍然是加密的结果，将其解密所得到的结果与对明文进行同样的运算结果是一样的。 即“对密文直接进行处理”与“对明文进行处理后并加密”其结果是一样的，这项技术 可以在加密的数据中进行诸如检索、比较等操作而无需对数据先进行解密，从根本上解 决将数据委托给第三方时的保密问题。</p></blockquote><h4 id="公钥加密-Asymmetric-Cryptography-Public-Key-Cryptography"><a href="#公钥加密-Asymmetric-Cryptography-Public-Key-Cryptography" class="headerlink" title="公钥加密/ Asymmetric Cryptography / Public Key Cryptography"></a>公钥加密/ Asymmetric Cryptography / Public Key Cryptography</h4><blockquote><p>公钥加密是一种特殊的加密手段，具有在同一时间生成两个密钥的处理(私钥和公钥)，每一个私钥都有一个相对应的公钥，从公钥不能推算出私钥，并且被用其中一个密钥加密了的数据，可以被另外一个相对应的密钥解密。这套系统使得节点可以先在网络中广播一个公钥给所有节点，然后所有节点就可以发送加密后的信息给该节点，而不需要预先交换密钥。</p></blockquote><h4 id="RSA-加密算法-RSA-Algorithm"><a href="#RSA-加密算法-RSA-Algorithm" class="headerlink" title="RSA 加密算法/ RSA Algorithm"></a>RSA 加密算法/ RSA Algorithm</h4><blockquote><p>RSA 公开密钥密码体制是使用不同的加密密钥与解密密钥，是一种“由已知加密密钥 推导出解密密钥在计算上是不可行的”密码体制。它通常是先生成一对 RSA 密钥，其 中之一是保密密钥，由用户保存; 另一个为公开密钥，可对外公开，甚至可在网络服务器中注册。</p></blockquote><h4 id="椭圆加密算法-Elliptic-Curve-Cryptography-ECC"><a href="#椭圆加密算法-Elliptic-Curve-Cryptography-ECC" class="headerlink" title="椭圆加密算法/ Elliptic Curve Cryptography / ECC"></a>椭圆加密算法/ Elliptic Curve Cryptography / ECC</h4><blockquote><p>椭圆加密算法是一种公钥加密体制，最初由 Koblitz 和 Miller 两人于 1985 年提出，其 数学基础是利用椭圆曲线上的有理点构成 Abel 加法群上椭圆离散对数的计算困难性。</p></blockquote><h4 id="明文-Plaintext"><a href="#明文-Plaintext" class="headerlink" title="明文/ Plaintext"></a>明文/ Plaintext</h4><blockquote><p>在密码学中，明文是指传送方想要接收方获得的可读信息。明文经过加密所产生的信息被称为密文，而密文经过解密而还原得来的信息被称为明文。</p></blockquote><h4 id="密文-Ciphertext"><a href="#密文-Ciphertext" class="headerlink" title="密文/ Ciphertext"></a>密文/ Ciphertext</h4><blockquote><p>在密码学中，密文是明文经过加密算法所产生的。因为密文是一种除非使用恰当的算法进行解密，否则人类或计算机是不可以直接阅读理解的加密形态，可以理解为被加密的信息。</p></blockquote><h4 id="环签名-Ring-Signatures"><a href="#环签名-Ring-Signatures" class="headerlink" title="环签名/ Ring Signatures"></a>环签名/ Ring Signatures</h4><blockquote><p>因签名中参数 Ci(i=1,2,…,n)根据一定的规则首尾相接组成环状而得名。其实就是实 际的签名者用其他可能签字者的公钥产生一个带有断口的环，然后用私钥将断口连成一 个完整的环。任何验证人利用环成员的公钥都可以验证一个环签名是否由某个可能的签 名人生成。</p></blockquote><h4 id="数字签名-Digital-Signatures"><a href="#数字签名-Digital-Signatures" class="headerlink" title="数字签名/ Digital Signatures"></a>数字签名/ Digital Signatures</h4><blockquote><p>数字签名(又称公钥数字签名、电子签名)是一种类似写在纸上的签名，但是使用了公 钥加密领域的技术实现，用于鉴别数字信息的方法，在网络上可以使用数字签名来进行 身份确认。数字签名是一个独一无二的数值，若公钥能通过验证，那我们就能确定对应 的公钥的正确性，数字签名兼具可确认性和不可否认性。</p></blockquote><h4 id="多重签名-Multi-Signatures"><a href="#多重签名-Multi-Signatures" class="headerlink" title="多重签名/ Multi-Signatures"></a>多重签名/ Multi-Signatures</h4><blockquote><p>多重签名意味着在交易发生之前需要多个签名或批准。多重签名会增加加密货币的安全性，这样一个人就不能在未经他人同意的情况下把所有的数字货币都拿走。</p></blockquote><h4 id="数字证书-Digital-Certificate"><a href="#数字证书-Digital-Certificate" class="headerlink" title="数字证书/ Digital Certificate"></a>数字证书/ Digital Certificate</h4><blockquote><p>数字证书是区块链中标识各个节点的身份信息的一串数字，用以证明公钥的归属以及内容信息的合法性，在区块链的非对称加密中，一旦通过中间人攻击将公钥替换后将会破坏区块链的安全体系，因此通过共识机制建立互相承认的数字证书机制，在不需要第三方的情况下识别数据的合法性。</p></blockquote><h4 id="哈希-散列-Hash"><a href="#哈希-散列-Hash" class="headerlink" title="哈希/ 散列/ Hash"></a>哈希/ 散列/ Hash</h4><blockquote><p>哈希又称作“散列”，是一种数学计算机程序，它接收任何一组任意长度的输入信息， 通过哈希算法变换成固定长度的数据指纹输出形式，如字母和数字的组合，该输出就是<br>“哈希值”。哈希使存储和查找信息速度更快，因为哈希值通常更短所以更容易被找到。 同时哈希能够对信息进行加密，一个好的哈希函数在输入域中很少出现哈希冲突，哈希 一个特定文档的结果总是一样的，但找到具有相同哈希值的两个文件在计算上是计算上 不可行的。</p></blockquote><h4 id="安全哈希算法-Secure-Hash-Algorithm-256-SHA-256"><a href="#安全哈希算法-Secure-Hash-Algorithm-256-SHA-256" class="headerlink" title="安全哈希算法/ Secure Hash Algorithm 256 / SHA 256"></a>安全哈希算法/ Secure Hash Algorithm 256 / SHA 256</h4><blockquote><p>SHA 256 是 SHA 系列算法之一，由美国国安局设计、美国国家标准与技术研究院发布 的一套哈希算法，由于其摘要长度为 256bits，故称 SHA 256。SHA 256 是保护数字信息的最安全的方法之一。</p></blockquote><h4 id="钥匙-Key"><a href="#钥匙-Key" class="headerlink" title="钥匙/ Key"></a>钥匙/ Key</h4><blockquote><p>钥匙是使隐藏的、不可读的信息可读的一串秘密字母和数字。</p></blockquote><h4 id="密钥-Secret-Key"><a href="#密钥-Secret-Key" class="headerlink" title="密钥/ Secret Key"></a>密钥/ Secret Key</h4><blockquote><p>密钥是用于加密或解密信息的一段参数，在非对称加密系统中，是通过利用公钥(账 户)与私钥(密码)的配合而实现的。</p></blockquote><h4 id="公钥-Public-Key"><a href="#公钥-Public-Key" class="headerlink" title="公钥/ Public Key"></a>公钥/ Public Key</h4><blockquote><p>公钥与私钥是通过一种算法得到的一个密钥对，公钥是密钥对中公开的部分，私钥则是非公开的部分，公钥通常用于加密会话密钥、验证数字签名，或加密可以用相应的私钥解密的数据。</p></blockquote><h4 id="私钥-Private-Key"><a href="#私钥-Private-Key" class="headerlink" title="私钥/ Private Key"></a>私钥/ Private Key</h4><blockquote><p>公钥与私钥是通过一种算法得到的一个密钥对，公钥是密钥对中公开的部分，私钥则是非公开的部分，私钥是指与一个地址(地址是与私钥相对应的公钥的哈希值)相关联的 一把密钥，是只有你自己才知道的一串字符，可用来操作账户里的加密货币。</p></blockquote><h4 id="零知识证明-Zero-Knowledge-Proof"><a href="#零知识证明-Zero-Knowledge-Proof" class="headerlink" title="零知识证明/ Zero-Knowledge Proof"></a>零知识证明/ Zero-Knowledge Proof</h4><blockquote><p>证明者和验证者之间进行交互，证明者能够在不向验证者提供任何有用的信息的情况 下，使验证者相信某个论断是正确的。</p></blockquote><h4 id="计算上不可行-Computationally-Feasible"><a href="#计算上不可行-Computationally-Feasible" class="headerlink" title="计算上不可行/ Computationally Feasible"></a>计算上不可行/ Computationally Feasible</h4><blockquote><p>密码算法依赖的原理是当前计算不可行的数学问题，而“计算不可行”是一个在时间及 空间上相对而言的概念，计算上不可行即表示一个程序是可处理的但是需要一个长得不 切实际的时间(如几十亿年)来处理的步骤。通常认为 2 的 80 次方个计算步骤是计算 上不可行的下限。</p></blockquote><h4 id="暴力破解法-Brute-Force-Attack-BFA"><a href="#暴力破解法-Brute-Force-Attack-BFA" class="headerlink" title="暴力破解法/ Brute Force Attack / BFA"></a>暴力破解法/ Brute Force Attack / BFA</h4><blockquote><p>暴力破解法又名穷举法，是一种密码分析的方法，通过逐个推算猜测每一个可能解锁安全系统的密钥来获取信息的方法。</p></blockquote><h3 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h3><h4 id="分布式存储-Distributed-Data-Store-DDS"><a href="#分布式存储-Distributed-Data-Store-DDS" class="headerlink" title="分布式存储/ Distributed Data Store / DDS"></a>分布式存储/ Distributed Data Store / DDS</h4><blockquote><p>传统上的分布式存储本质上是一个中心化的系统，是将数据分散存储在多台独立的设备上，采用可扩展的系统结构、利用多台存储服务器分担存储负荷、利用位置服务器定位存储信息。而基于 P2P 网络的分布式存储是区块链的核心技术，是将数据存储于区块 上并通过开放节点的存储空间建立的一种分布式数据库，解决传统分布式存储的问题。</p></blockquote><h4 id="P2P-存储-Peer-to-Peer-Storage-P2P-Storage"><a href="#P2P-存储-Peer-to-Peer-Storage-P2P-Storage" class="headerlink" title="P2P 存储/ Peer-to-Peer Storage / P2P Storage"></a>P2P 存储/ Peer-to-Peer Storage / P2P Storage</h4><blockquote><p>P2P 存储是一种不存在中心化控制机制的存储技术。P2P 存储通过开放节点的存储空 间，以提高网络的运作效率，解决传统分布式存储的服务器瓶颈、带宽而带来的访问不 便等问题。</p></blockquote><h4 id="分布式-Distributed"><a href="#分布式-Distributed" class="headerlink" title="分布式/ Distributed"></a>分布式/ Distributed</h4><blockquote><p>分布式是通过区块链的 P2P 技术实现，分布式是描述一个计算机系统具有在多台计算 机上同时运行和维护的完整副本，没有任何人或组织来控制这个系统。</p></blockquote><h4 id="账本-Ledger"><a href="#账本-Ledger" class="headerlink" title="账本/ Ledger"></a>账本/ Ledger</h4><blockquote><p>账本是指包括区块链的数据结构、所有的交易信息和当前状态的数字记录。</p></blockquote><h4 id="分布式账本-Distributed-ledger-Technology-DLT"><a href="#分布式账本-Distributed-ledger-Technology-DLT" class="headerlink" title="分布式账本/ Distributed ledger Technology / DLT"></a>分布式账本/ Distributed ledger Technology / DLT</h4><blockquote><p>分布式账本是指一种在网络成员之间共享、复制和同步的数据库，分布式账本在区块链中是一个通过共识机制建立的数字记录，区块链网络中的参与者可以获得一个唯一、真实账本的副本，因此难以对分布式账本进行篡改。更改记录的方式非常困难，技术非常安全。</p></blockquote><h4 id="节点-Node"><a href="#节点-Node" class="headerlink" title="节点/ Node"></a>节点/ Node</h4><blockquote><p>节点是区块链分布式系统中的网络节点，是通过网络连接的服务器、计算机、电话等，针对不同性质的区块链，成为节点的方式也会有所不同。以比特币为例，参与交易或挖矿即构成一个节点。</p></blockquote><h4 id="全节点-完整节点-Full-Node"><a href="#全节点-完整节点-Full-Node" class="headerlink" title="全节点/ 完整节点/ Full Node"></a>全节点/ 完整节点/ Full Node</h4><blockquote><p>全节点是是拥有完整区块链账本的节点，全节点需要占用内存同步所有的区块链数据，能够独立校验区块链上的所有交易并实时更新数据，主要负责区块链的交易的广播和验证。</p></blockquote><h3 id="共识机制"><a href="#共识机制" class="headerlink" title="共识机制"></a>共识机制</h3><h4 id="共识机制-Consensus"><a href="#共识机制-Consensus" class="headerlink" title="共识机制/ Consensus"></a>共识机制/ Consensus</h4><blockquote><p>由于点对点网络下存在较高的网络延迟，各个节点所观察到的事务先后顺序不可能完全一致。因此区块链系统需要设计一种机制对在差不多时间内发生的事务的先后顺序进行共识，这种对一个时间窗口内的事务的先后顺序达成共识的算法被称为“共识机制”。</p></blockquote><h4 id="工作量证明-Proof-of-Work-PoW"><a href="#工作量证明-Proof-of-Work-PoW" class="headerlink" title="工作量证明/ Proof of Work / PoW"></a>工作量证明/ Proof of Work / PoW</h4><blockquote><p>工作量证明简单理解就是一份证明，用来确认节点做过一定量的工作。监测工作的整个过程通常是极为低效的，而通过对工作的结果进行认证来证明完成了相应的工作量，则是一种非常高效的方式。比特币在区块的生成过程中使用了 PoW 机制，要得到合理的 随机数求解数学难题需要经过大量尝试计算，通过查看记录和验证区块链信息的证明， 就能知道是否完成了指定难度系数的工作量。</p></blockquote><h4 id="权益证明-Proof-of-Stake-PoS"><a href="#权益证明-Proof-of-Stake-PoS" class="headerlink" title="权益证明/ Proof of Stake / PoS"></a>权益证明/ Proof of Stake / PoS</h4><blockquote><p>PoS 也称权益证明机制，类似于把资产存在银行里，银行会通过你持有数字资产的数量和时间给你分配相应的收益。采用 PoS 机制的加密货币资产，系统会根据节点的持币数量和时间的乘积(币天数)给节点分配相应的权益。</p></blockquote><h4 id="权益授权证明-Delegated-Proof-of-Stake-DPoS"><a href="#权益授权证明-Delegated-Proof-of-Stake-DPoS" class="headerlink" title="权益授权证明/ Delegated Proof of Stake / DPoS"></a>权益授权证明/ Delegated Proof of Stake / DPoS</h4><blockquote><p>DPoS 是一种类似董事会的授权共识机制，该机制让每一个持币人对整个系统的节点进 行投票，决定哪些节点可以被信任并代理他们进行验证和记账，同时生成少量的对应奖 励。DPoS 大幅提高区块链的处理能力，并降低区块链的维护成本，从而使交易速度接 近于中心化的结算系统。</p></blockquote><h4 id="燃烧证明-Proof-of-Burn-PoB"><a href="#燃烧证明-Proof-of-Burn-PoB" class="headerlink" title="燃烧证明/ Proof of Burn / PoB"></a>燃烧证明/ Proof of Burn / PoB</h4><blockquote><p>燃烧证明是一种投资于全新的加密货币的方法:为了获得一种新的货币，你必须“烧 掉”(摧毁)另一种货币，比如比特币。从理论上讲，这将使每一种新的加密货币价值 相当于被摧毁的币的价值，但实际上你不能真的摧毁加密货币，系统需要你把它送到一 个会减少它的总供应量的地方。</p></blockquote><h4 id="开发者证明-Proof-of-Developer-PoD"><a href="#开发者证明-Proof-of-Developer-PoD" class="headerlink" title="开发者证明/ Proof of Developer / PoD"></a>开发者证明/ Proof of Developer / PoD</h4><blockquote><p>开发者证明是一个真实的、活的软件开发人员创建了一种加密货币的证据。它用于启动新的加密货币，以防止匿名开发人员在不提供可行的加密货币的情况下收集和窃取资 金。</p></blockquote><h4 id="重要性证明-Proof-of-Important-PoI"><a href="#重要性证明-Proof-of-Important-PoI" class="headerlink" title="重要性证明/ Proof of Important / PoI"></a>重要性证明/ Proof of Important / PoI</h4><blockquote><p>重要性证明是根据交易量、活跃度等维度而不仅仅是根据工作量和币的数量来决定区块链的记账权力。</p></blockquote><h4 id="基于交易的权益证明机制-Transaction-as-Proof-of-Stake-TaPOS"><a href="#基于交易的权益证明机制-Transaction-as-Proof-of-Stake-TaPOS" class="headerlink" title="基于交易的权益证明机制/ Transaction as Proof of Stake / TaPOS"></a>基于交易的权益证明机制/ Transaction as Proof of Stake / TaPOS</h4><blockquote><p>TaPOS 为股东们提供了一个长效机制来直接批准他们的代表的行为，平均而言，51% 的股东在 6 个月内会直接确认每个区块，取决于活跃流通的股份所占的比例，差不多 10% 的股东可以在几天内确认区块链。这种方式直接确认保障了网络的长期安全，并使 所有的攻击尝试变得极度清晰易见。</p></blockquote><h4 id="瑞波共识机制-Ripple-Consensus"><a href="#瑞波共识机制-Ripple-Consensus" class="headerlink" title="瑞波共识机制/ Ripple Consensus"></a>瑞波共识机制/ Ripple Consensus</h4><blockquote><p>瑞波共识算法使一组节点能够基于特殊节点列表达成共识，初始特殊节点列表就像一个俱乐部，要接纳一个新成员，必须由 51% 的该俱乐部会员投票通过。共识遵循核心成 员 51% 权力规则，外部人员则没有影响力。</p></blockquote><h4 id="分布式共识-Distributed-Consensus"><a href="#分布式共识-Distributed-Consensus" class="headerlink" title="分布式共识/ Distributed Consensus"></a>分布式共识/ Distributed Consensus</h4><blockquote><p>所有的节点必须定期更新彼此之间的不断复制的状况，通过专门的槽位来识别每一个更新。当所有节点更新了他们的分类账并放映的值相同时，就可达成共识，会将协商一致的声明具体化并发布至它们的分类账副本去。</p></blockquote><h4 id="验证池机制-POOL"><a href="#验证池机制-POOL" class="headerlink" title="验证池机制/ POOL"></a>验证池机制/ POOL</h4><blockquote><p>验证池机制是基于传统的分布式一致性技术和数据验证机制的结合，它使得在成熟的分布式一致性算法(Pasox、Raft)基础上，不需要代币也能实现秒级共识验证。</p></blockquote><h4 id="51-攻击-51-attack"><a href="#51-攻击-51-attack" class="headerlink" title="51% 攻击/ 51% attack"></a>51% 攻击/ 51% attack</h4><blockquote><p>51% 攻击，是指利用比特币以算力作为竞争条件的特点，凭借算力优势篡改或者撤销自己的付款交易。如果有人掌握了 50% 以上的算力，他能够比其他人更快地找到开采区块需要的那个随机数，因此他能够比其他人更快地创建区块。</p></blockquote><h4 id="双重支付-双重花费-双花-Double"><a href="#双重支付-双重花费-双花-Double" class="headerlink" title="双重支付/ 双重花费/ 双花/ Double"></a>双重支付/ 双重花费/ 双花/ Double</h4><blockquote><p>Spending 双重支付是一个故意的分叉，是指具有大量计算能力的节点发送一个交易请求并购买资 产，在收到资产后又做出另外一个交易将相同量的币发给自己。攻击者通过创造一个分 叉区块，将原始交易及伪造交易放在该区块上并基于该分叉上开始挖矿。如果攻击者 有超过 50% 的计算能力，双重花费最终可以在保证在任何区块深度上成功；如果低于 50% 则有部分可能性成功。</p></blockquote><h4 id="拜占庭将军问题-Byzantine-Generals-Problem-BGP"><a href="#拜占庭将军问题-Byzantine-Generals-Problem-BGP" class="headerlink" title="拜占庭将军问题/ Byzantine Generals Problem / BGP"></a>拜占庭将军问题/ Byzantine Generals Problem / BGP</h4><blockquote><p>拜占庭将军问题是指“在存在消息丢失的不可靠信道上试图通过消息传递的方式达到一 致性是不可能的”。因此在系统中存在除了消息延迟或不可送达的故障以外的错误，包 括消息被篡改、节点不按照协议进行处理等，将会潜在地会对系统造成针对性的破坏。</p></blockquote><h4 id="改进型实用拜占庭容错-Practical-Byzantine-Fault-Tolerance-PBFT"><a href="#改进型实用拜占庭容错-Practical-Byzantine-Fault-Tolerance-PBFT" class="headerlink" title="改进型实用拜占庭容错/ Practical Byzantine Fault Tolerance / PBFT"></a>改进型实用拜占庭容错/ Practical Byzantine Fault Tolerance / PBFT</h4><blockquote><p>PBET 共识机制是少数服从多数，根据信息在分布式网络中节点间互相交换后各节点列 出所有得到的信息，一个节点代表一票，选择大多数的结果作为解决办法。PBET 将容 错量控制在全部节点数的1/3，即如只要有超过 2/3 的正常节点，整个系统便可正常运作。</p></blockquote><h4 id="授权拜占庭容错算法-Delegated-Byzantine-Fault-Tolerance-dBFT"><a href="#授权拜占庭容错算法-Delegated-Byzantine-Fault-Tolerance-dBFT" class="headerlink" title="授权拜占庭容错算法/ Delegated Byzantine Fault Tolerance / dBFT"></a>授权拜占庭容错算法/ Delegated Byzantine Fault Tolerance / dBFT</h4><blockquote><p>dBFT，是基于持有权益比例来选出专门的记账人(记账节点)，然后记账人之间通过拜 占庭容错算法(即少数服从多数的投票机制)来达成共识，决定动态参与节点。dBFT 可以容忍任何类型的错误，且专门的多个记账人使得每一个区块都有最终性、不会分 叉。</p></blockquote><h4 id="联邦拜占庭协议-Federated-Byzantine-Agreement-FBA"><a href="#联邦拜占庭协议-Federated-Byzantine-Agreement-FBA" class="headerlink" title="联邦拜占庭协议/ Federated Byzantine Agreement / FBA"></a>联邦拜占庭协议/ Federated Byzantine Agreement / FBA</h4><blockquote><p>联邦拜占庭协议的主要特性是去中心化和任意行为容错，通过分布式的方法，达到法定人数或者节点足够的群体能达成共识，每一个节点不需要依赖相同的参与者就能决定信任的对象来完成共识。</p></blockquote><h2 id="区块链的衍生技术"><a href="#区块链的衍生技术" class="headerlink" title="区块链的衍生技术"></a>区块链的衍生技术</h2><h2 id="区块链的技术应用"><a href="#区块链的技术应用" class="headerlink" title="区块链的技术应用"></a>区块链的技术应用</h2><h2 id="数字货币的交易"><a href="#数字货币的交易" class="headerlink" title="数字货币的交易"></a>数字货币的交易</h2><h2 id="风险和监管"><a href="#风险和监管" class="headerlink" title="风险和监管"></a>风险和监管</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文由 &lt;strong&gt;维京研究院 &amp;amp; 甲子智库&lt;/strong&gt; 合力推出的 《&lt;strong&gt;区块链行业词典&lt;/strong&gt;》 整理记录；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;民间暗语（小白入门首选）&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="区块链" scheme="http://vmee.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="100days" scheme="http://vmee.top/tags/100days/"/>
    
      <category term="基础理论" scheme="http://vmee.top/tags/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
      <category term="blockchain" scheme="http://vmee.top/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>分布式一致性与共识算法及PoW、PoS、DPoS 综述</title>
    <link href="http://vmee.top/2018/07/13/consensus-and-pow-and-pos/"/>
    <id>http://vmee.top/2018/07/13/consensus-and-pow-and-pos/</id>
    <published>2018-07-12T17:22:29.000Z</published>
    <updated>2018-07-12T17:22:29.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文旨在记录拜读 <a href="https://daimajia.com/" target="_blank" rel="noopener">代码家</a>、<a href="https://draveness.me/" target="_blank" rel="noopener">Draveness</a> 两位博主的系列文章后整理的读书笔记。</p></blockquote><h3 id="分布式一致性与共识算法"><a href="#分布式一致性与共识算法" class="headerlink" title="分布式一致性与共识算法"></a>分布式一致性与共识算法</h3><p><a href="https://draveness.me/consensus" target="_blank" rel="noopener">分布式一致性与共识算法</a></p><h3 id="PoW、PoS、DPoS-综述"><a href="#PoW、PoS、DPoS-综述" class="headerlink" title="PoW、PoS、DPoS 综述"></a>PoW、PoS、DPoS 综述</h3><p><a href="https://daimajia.com/2017/09/14/pow-and-pos" target="_blank" rel="noopener">PoW、PoS、DPoS 综述</a></p><h3 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文旨在记录拜读 &lt;a href=&quot;https://daimajia.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;代码家&lt;/a&gt;、&lt;a href=&quot;https://draveness.me/&quot; target=&quot;_bla
      
    
    </summary>
    
      <category term="区块链" scheme="http://vmee.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="100days" scheme="http://vmee.top/tags/100days/"/>
    
      <category term="分布式" scheme="http://vmee.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="一致性" scheme="http://vmee.top/tags/%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
      <category term="PoW" scheme="http://vmee.top/tags/PoW/"/>
    
      <category term="PoS" scheme="http://vmee.top/tags/PoS/"/>
    
      <category term="共识算法" scheme="http://vmee.top/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基于 VPS 搭建 Shadowsocks 服务端及客户端配置</title>
    <link href="http://vmee.top/2018/07/13/how-to-build-a-ss-vps-server/"/>
    <id>http://vmee.top/2018/07/13/how-to-build-a-ss-vps-server/</id>
    <published>2018-07-12T16:51:12.000Z</published>
    <updated>2018-07-12T16:55:47.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="云服务器选择"><a href="#云服务器选择" class="headerlink" title="云服务器选择"></a>云服务器选择</h3><blockquote><p>自用：<a href="https://www.vultr.com/" target="_blank" rel="noopener">https://www.vultr.com/</a> （自选 / 费用适中 / 适合建站 / 日本节点部分IP容易被墙）</p></blockquote><blockquote><p>备胎：<a href="https://cn.aliyun.com/" target="_blank" rel="noopener">https://cn.aliyun.com/</a>  （自选 / 优惠活动 / 容易受国家政策干预）</p></blockquote><blockquote><p>对比：<a href="https://www.10besty.com/best-vps-hosting-services/" target="_blank" rel="noopener">https://www.10besty.com/best-vps-hosting-services/</a></p></blockquote><h3 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><h4 id="安装-Python-环境"><a href="#安装-Python-环境" class="headerlink" title="安装 Python 环境"></a>安装 Python 环境</h4><blockquote><p>本教程基于 Linux CentOS 7</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># install in linux centos 7</span><br><span class="line">$ yum install m2crypto python-setuptools</span><br><span class="line"></span><br><span class="line"># pip</span><br><span class="line">$ easy_install pip</span><br><span class="line"></span><br><span class="line"># install shadowsocks</span><br><span class="line">$ pip install shadowsocks</span><br></pre></td></tr></table></figure><h4 id="添加-SS-配置"><a href="#添加-SS-配置" class="headerlink" title="添加 SS 配置"></a>添加 SS 配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># add config file</span><br><span class="line">$ vi /etc/shadowsocks.json</span><br></pre></td></tr></table></figure><blockquote><p>内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;0.0.0.0&quot;,</span><br><span class="line">    &quot;server_port&quot;:8888,   // 自定义端口号</span><br><span class="line">    &quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;local_port&quot;:1080,</span><br><span class="line">    &quot;password&quot;:&quot;yourspwd&quot;,// 自定义密码</span><br><span class="line">    &quot;timeout&quot;:300,</span><br><span class="line">    &quot;method&quot;:&quot;aes-256-cfb&quot;,// 选择加密方式</span><br><span class="line">    &quot;fast_open&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="开启防火墙"><a href="#开启防火墙" class="headerlink" title="开启防火墙"></a>开启防火墙</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># install</span><br><span class="line">$ yum install firewalld</span><br><span class="line"></span><br><span class="line"># start</span><br><span class="line">$ systemctl start firewalld</span><br></pre></td></tr></table></figure><h4 id="防火墙监听端口"><a href="#防火墙监听端口" class="headerlink" title="防火墙监听端口"></a>防火墙监听端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># server_port</span><br><span class="line">$ firewall-cmd --permanent --zone=public --add-port=server_port/tcp</span><br><span class="line">$ firewall-cmd --reload</span><br></pre></td></tr></table></figure><h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># start server</span><br><span class="line">$ ssserver -c /etc/shadowsocks.json</span><br><span class="line"></span><br><span class="line"># set nohup</span><br><span class="line">$ nohup ssserver -c /etc/shadowsocks.json</span><br></pre></td></tr></table></figure><h4 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># add command to /etc/rc.local</span><br><span class="line">$ vi /etc/rc.local</span><br></pre></td></tr></table></figure><blockquote><p>内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># THIS FILE IS ADDED FOR COMPATIBILITY PURPOSES</span><br><span class="line">#</span><br><span class="line"># It is highly advisable to create own systemd services or udev rules</span><br><span class="line"># to run scripts during boot instead of using this file.</span><br><span class="line">#</span><br><span class="line"># In contrast to previous versions due to parallel execution during boot</span><br><span class="line"># this script will NOT be run after all other services.</span><br><span class="line">#</span><br><span class="line"># Please note that you must run &apos;chmod +x /etc/rc.d/rc.local&apos; to ensure</span><br><span class="line"># that this script will be executed during boot.</span><br><span class="line">touch /var/lock/subsys/local</span><br><span class="line">/usr/bin/ssserver -c /etc/shadowsocks.json -d start</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h3><blockquote><p>MacOS 软件下载地址：<a href="https://pan.baidu.com/s/17B8DmYY5SvUWnlMU8ZOLlQ" target="_blank" rel="noopener">ShadowsocksX-NG</a> 密码：gunx</p></blockquote><blockquote><p>手机 App Store 搜索 Shadowing 有惊喜</p></blockquote><blockquote><p><a href="https://help.fyvps.com/index.php/archives/51/" target="_blank" rel="noopener">SS客户端各个版本下载地址</a></p></blockquote><h4 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h4><ul><li style="list-style: none"><input type="checkbox" checked> 安装：过程略过，绿色软件解压缩打开即用。</li><li style="list-style: none"><input type="checkbox" checked> 配置：电脑设置如下图所示</li></ul><p><img src="http://pbcq37bxu.bkt.clouddn.com/ss-server-config.jpg" alt="image"></p><ul><li style="list-style: none"><input type="checkbox" checked> 使用：轻触打开 Shadowsocks 开始墙外看世界吧！</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><blockquote><ol><li>遵纪守法，非礼勿视；</li><li>严禁商用，后果自负；</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;云服务器选择&quot;&gt;&lt;a href=&quot;#云服务器选择&quot; class=&quot;headerlink&quot; title=&quot;云服务器选择&quot;&gt;&lt;/a&gt;云服务器选择&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;自用：&lt;a href=&quot;https://www.vultr.com/&quot; targe
      
    
    </summary>
    
      <category term="奇淫技巧" scheme="http://vmee.top/categories/%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="VPN" scheme="http://vmee.top/tags/VPN/"/>
    
      <category term="VPS" scheme="http://vmee.top/tags/VPS/"/>
    
      <category term="SS" scheme="http://vmee.top/tags/SS/"/>
    
      <category term="技巧" scheme="http://vmee.top/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Golang 新开发者要注意的陷阱和常见错误【初级篇】</title>
    <link href="http://vmee.top/2018/07/11/gotchas-and-common-mistakes-in-go-golang/"/>
    <id>http://vmee.top/2018/07/11/gotchas-and-common-mistakes-in-go-golang/</id>
    <published>2018-07-10T16:36:34.000Z</published>
    <updated>2018-07-10T16:56:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文（EN）：<a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/" target="_blank" rel="noopener">50 Shades of Go: Traps, Gotchas, and Common Mistakes for New Golang Devs</a></p><p>原文（CN）：<a href="http://colobu.com/2015/09/07/gotchas-and-common-mistakes-in-go-golang/" target="_blank" rel="noopener">鸟窝大神博客</a></p><p>本文只涉及其中的初级相关内容，后续深入学习实践后再行归纳总结中级和高级内容。</p><hr><h3 id="1-开（左）大括号不能放在单独的一行"><a href="#1-开（左）大括号不能放在单独的一行" class="headerlink" title="1.开（左）大括号不能放在单独的一行"></a>1.开（左）大括号不能放在单独的一行</h3><p>在大多数其他使用大括号的语言中，你需要选择放置它们的位置。Go 的方式不同，你可以为此感谢下自动分号的注入（没有预读）。是的，Go 中也是有分号的：-）</p><p>错误示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main()</span><br><span class="line">&#123;// error, can&apos;t have the opening brace on a separate line</span><br><span class="line">fmt.Println(&quot;Hello world!&quot;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译错误：</p><blockquote><p>./basic.go:43:1: syntax error: unexpected semicolon or newline before {</p></blockquote><p>有效示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;Hello world!&quot;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-未使用的变量"><a href="#2-未使用的变量" class="headerlink" title="2.未使用的变量"></a>2.未使用的变量</h3><p>如果你有未使用的变量，代码将编译失败。当然也有例外。在函数内一定要使用声明的变量，但未使用的全局变量是没问题的。<br>如果你给未使用的变量分配了一个新的值，代码还是会编译失败。你需要在某个地方使用这个变量，才能让编译器愉快的编译。</p><p>错误示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">var gvar int //not an error</span><br><span class="line"></span><br><span class="line">func main() &#123;  </span><br><span class="line">    var one int   //error, unused variable</span><br><span class="line">    two := 2      //error, unused variable</span><br><span class="line">    var three int //error, even though it&apos;s assigned 3 on the next line</span><br><span class="line">    three = 3     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译错误：</p><blockquote><p>/tmp/sandbox473116179/main.go:6: one declared and not used<br>/tmp/sandbox473116179/main.go:7: two declared and not used<br>/tmp/sandbox473116179/main.go:8: three declared and not used</p></blockquote><p>有效示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;  </span><br><span class="line">    var one int</span><br><span class="line">    _ = one</span><br><span class="line">    two := 2 </span><br><span class="line">    fmt.Println(two)</span><br><span class="line">    var three int </span><br><span class="line">    three = 3</span><br><span class="line">    one = three</span><br><span class="line">    var four int</span><br><span class="line">    four = four</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>另一个选择是注释掉或者移除未使用的变量 ：-）</p><h3 id="3-未使用的Imports"><a href="#3-未使用的Imports" class="headerlink" title="3.未使用的Imports"></a>3.未使用的Imports</h3><p>如果你引入一个包，而没有使用其中的任何函数、接口、结构体或者变量的话，代码将会编译失败。<br>你可以使用 goimports 来增加引入或者移除未使用的引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get golang.org/x/tools/cmd/goimports</span><br></pre></td></tr></table></figure></p><p>如果你真的需要引入的包，你可以添加一个下划线标记符，_，来作为这个包的名字，从而避免编译失败。下滑线标记符用于引入，但不使用。</p><p>错误示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (  </span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;log&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译错误：</p><blockquote><p>/tmp/sandbox627475386/main.go:4: imported and not used: “fmt”<br>/tmp/sandbox627475386/main.go:5: imported and not used: “log”<br>/tmp/sandbox627475386/main.go:6: imported and not used: “time”</p></blockquote><p>有效示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (  </span><br><span class="line">    _ &quot;fmt&quot;</span><br><span class="line">    &quot;log&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line">var _ = log.Println</span><br><span class="line">func main() &#123;  </span><br><span class="line">    _ = time.Now</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>另一个选择是移除或者注释掉未使用的imports ：-）</p><h3 id="4-简式的变量声明仅可以在函数内部使用"><a href="#4-简式的变量声明仅可以在函数内部使用" class="headerlink" title="4.简式的变量声明仅可以在函数内部使用"></a>4.简式的变量声明仅可以在函数内部使用</h3><p>错误示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">myvar := 1 //error</span><br><span class="line"></span><br><span class="line">func main() &#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译错误：</p><blockquote><p>/tmp/sandbox265716165/main.go:3: non-declaration statement outside function body</p></blockquote><p>有效示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">var myvar = 1</span><br><span class="line"></span><br><span class="line">func main() &#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="5-使用简式声明重复声明变量"><a href="#5-使用简式声明重复声明变量" class="headerlink" title="5.使用简式声明重复声明变量"></a>5.使用简式声明重复声明变量</h3><p>你不能在一个单独的声明中重复声明一个变量，但在多变量声明中这是允许的，其中至少要有一个新的声明变量。<br>重复变量需要在相同的代码块内，否则你将得到一个隐藏变量。<br>错误示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;  </span><br><span class="line">    one := 0</span><br><span class="line">    one := 1 //error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译错误：</p><blockquote><p>/tmp/sandbox706333626/main.go:5: no new variables on left side of :=</p></blockquote><p>有效示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;  </span><br><span class="line">    one := 0</span><br><span class="line">    one, two := 1,2</span><br><span class="line">    one,two = two,one</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文（EN）：&lt;a href=&quot;http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;50 Shades of Go: 
      
    
    </summary>
    
      <category term="他山之石" scheme="http://vmee.top/categories/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3/"/>
    
    
      <category term="100days" scheme="http://vmee.top/tags/100days/"/>
    
      <category term="技巧" scheme="http://vmee.top/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="golang" scheme="http://vmee.top/tags/golang/"/>
    
      <category term="常见错误" scheme="http://vmee.top/tags/%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"/>
    
  </entry>
  
  <entry>
    <title>创世博客之 Hello World</title>
    <link href="http://vmee.top/2018/07/10/creation-hello-world/"/>
    <id>http://vmee.top/2018/07/10/creation-hello-world/</id>
    <published>2018-07-10T15:01:22.000Z</published>
    <updated>2018-07-10T16:56:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="奇淫技巧" scheme="http://vmee.top/categories/%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="blog" scheme="http://vmee.top/tags/blog/"/>
    
      <category term="hexo" scheme="http://vmee.top/tags/hexo/"/>
    
      <category term="next" scheme="http://vmee.top/tags/next/"/>
    
  </entry>
  
</feed>
